{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/RaziSidd/Collab-and-Jupyter-Notebook/blob/main/K%20value%20\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "J1grKKjV-nzO",
        "outputId": "733df13b-bb69-4656-fd8a-2d4d04049eaf",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: librosa in /usr/local/lib/python3.10/dist-packages (0.10.1)\n",
            "Requirement already satisfied: audioread>=2.1.9 in /usr/local/lib/python3.10/dist-packages (from librosa) (3.0.1)\n",
            "Requirement already satisfied: numpy!=1.22.0,!=1.22.1,!=1.22.2,>=1.20.3 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.23.5)\n",
            "Requirement already satisfied: scipy>=1.2.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.11.4)\n",
            "Requirement already satisfied: scikit-learn>=0.20.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.2.2)\n",
            "Requirement already satisfied: joblib>=0.14 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.3.2)\n",
            "Requirement already satisfied: decorator>=4.3.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (4.4.2)\n",
            "Requirement already satisfied: numba>=0.51.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (0.58.1)\n",
            "Requirement already satisfied: soundfile>=0.12.1 in /usr/local/lib/python3.10/dist-packages (from librosa) (0.12.1)\n",
            "Requirement already satisfied: pooch>=1.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.8.0)\n",
            "Requirement already satisfied: soxr>=0.3.2 in /usr/local/lib/python3.10/dist-packages (from librosa) (0.3.7)\n",
            "Requirement already satisfied: typing-extensions>=4.1.1 in /usr/local/lib/python3.10/dist-packages (from librosa) (4.5.0)\n",
            "Requirement already satisfied: lazy-loader>=0.1 in /usr/local/lib/python3.10/dist-packages (from librosa) (0.3)\n",
            "Requirement already satisfied: msgpack>=1.0 in /usr/local/lib/python3.10/dist-packages (from librosa) (1.0.7)\n",
            "Requirement already satisfied: llvmlite<0.42,>=0.41.0dev0 in /usr/local/lib/python3.10/dist-packages (from numba>=0.51.0->librosa) (0.41.1)\n",
            "Requirement already satisfied: platformdirs>=2.5.0 in /usr/local/lib/python3.10/dist-packages (from pooch>=1.0->librosa) (4.0.0)\n",
            "Requirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.10/dist-packages (from pooch>=1.0->librosa) (23.2)\n",
            "Requirement already satisfied: requests>=2.19.0 in /usr/local/lib/python3.10/dist-packages (from pooch>=1.0->librosa) (2.31.0)\n",
            "Requirement already satisfied: threadpoolctl>=2.0.0 in /usr/local/lib/python3.10/dist-packages (from scikit-learn>=0.20.0->librosa) (3.2.0)\n",
            "Requirement already satisfied: cffi>=1.0 in /usr/local/lib/python3.10/dist-packages (from soundfile>=0.12.1->librosa) (1.16.0)\n",
            "Requirement already satisfied: pycparser in /usr/local/lib/python3.10/dist-packages (from cffi>=1.0->soundfile>=0.12.1->librosa) (2.21)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests>=2.19.0->pooch>=1.0->librosa) (3.3.2)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests>=2.19.0->pooch>=1.0->librosa) (3.6)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests>=2.19.0->pooch>=1.0->librosa) (2.0.7)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests>=2.19.0->pooch>=1.0->librosa) (2023.11.17)\n"
          ]
        }
      ],
      "source": [
        "pip install librosa"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "0CQf65BS-nzT",
        "outputId": "3a9fdce3-4150-4b75-e82c-a3f9dc5217df",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 36
        }
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "'\\nPlease install this specific version of resampy for librosa to work without errors.\\n'"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "string"
            }
          },
          "metadata": {},
          "execution_count": 6
        }
      ],
      "source": [
        "'''\n",
        "Please install this specific version of resampy for librosa to work without errors.\n",
        "'''"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7FE1qM7n-nzU",
        "outputId": "4707813f-96ca-4786-b09e-ee1d0a4a4855",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Collecting resampy==0.3.1\n",
            "  Downloading resampy-0.3.1-py3-none-any.whl (3.1 MB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m3.1/3.1 MB\u001b[0m \u001b[31m13.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hRequirement already satisfied: numpy>=1.17 in /usr/local/lib/python3.10/dist-packages (from resampy==0.3.1) (1.23.5)\n",
            "Requirement already satisfied: numba>=0.47 in /usr/local/lib/python3.10/dist-packages (from resampy==0.3.1) (0.58.1)\n",
            "Requirement already satisfied: llvmlite<0.42,>=0.41.0dev0 in /usr/local/lib/python3.10/dist-packages (from numba>=0.47->resampy==0.3.1) (0.41.1)\n",
            "Installing collected packages: resampy\n",
            "Successfully installed resampy-0.3.1\n"
          ]
        }
      ],
      "source": [
        "pip install resampy==0.3.1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_hwFIUlFzTYw"
      },
      "outputs": [],
      "source": [
        "import soundfile\n",
        "import os\n",
        "import glob\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.model_selection import train_test_split\n",
        "import librosa\n",
        "from sklearn.svm import SVC, LinearSVC\n",
        "from sklearn.metrics import classification_report\n",
        "import warnings; warnings.filterwarnings('ignore')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "GWrZdqrp2E98"
      },
      "outputs": [],
      "source": [
        "emotions ={\n",
        "  '01':'neutral',\n",
        "  '02':'calm',\n",
        "  '03':'happy',\n",
        "  '04':'sad',\n",
        "  '05':'angry',\n",
        "  '06':'fearful',\n",
        "  '07':'disgust',\n",
        "  '08':'surprised'\n",
        "}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "UrgQMSEU-nzZ"
      },
      "source": [
        "### Data for binary classification\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "_Cgm89uTHx1q",
        "outputId": "0fca6506-78c3-4f89-f913-8c2a21f77720"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Mounted at /content/drive\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "vSe0sBT12HgO"
      },
      "outputs": [],
      "source": [
        "def load_extract_features(data_path):\n",
        "\n",
        "    '''\n",
        "    load_extract_features() is a function that is used to load all the audio files one at a time, compute their features and return the features as well as the target values.\n",
        "\n",
        "    There are around 8-10 audio files which are corrupted. We hardcode zero values for such files in order to maintain consistency.\n",
        "\n",
        "    ['calm', 'happy'] emotion data is categorized into 'positive' and  ['angry', 'fearful'] into 'negative'\n",
        "\n",
        "    Returns:\n",
        "    1. Features\n",
        "    2. Binary Target Values\n",
        "    '''\n",
        "    final_features,target_emotions, binary_label = [],[], []\n",
        "    count = 0\n",
        "\n",
        "    for i in glob.glob(data_path + \"/Actor_*/*.wav\"): #Loop to read every file.\n",
        "\n",
        "        name = os.path.basename(i)\n",
        "        #We split the name of the file to understand the emotion associated with the file.\n",
        "        split = name.split(\"-\")\n",
        "        #We know that the third identifier is associated with the emotion of the audio file. Hence, we use [2] as it represents the third identifier.\n",
        "        emotion = emotions[split[2]]\n",
        "\n",
        "        #Below is the code to categorize the emotions into two classes to make this a binary problem.\n",
        "        if emotion in ['calm', 'happy']:\n",
        "            binary_label.append(0)\n",
        "        elif emotion in ['angry', 'fearful']:\n",
        "            binary_label.append(1)\n",
        "        else:\n",
        "            continue\n",
        "\n",
        "        with soundfile.SoundFile(i) as audio:\n",
        "            waveform = audio.read(dtype=\"float32\")\n",
        "            sr = audio.samplerate\n",
        "\n",
        "            #Below is the code to extract the Mel spectrogram features\n",
        "            #128 is the standard for machine learning applications using Mel spectrograms\n",
        "            m_feature = librosa.feature.melspectrogram(y=waveform, sr=sr, n_mels=128, fmax=sr / 2.0).T\n",
        "            melspectrogram = np.mean(m_feature,axis=0)\n",
        "            if melspectrogram.shape != (128,):\n",
        "                melspectrogram = np.zeros(128)\n",
        "\n",
        "            #Below is the code to extract the chromagram features\n",
        "            stft_wave = librosa.stft(waveform)\n",
        "            stft = np.abs(stft_wave)\n",
        "            c_feature = librosa.feature.chroma_stft(S=stft, sr=sr).T\n",
        "            chromagram = np.mean(c_feature,axis=0)\n",
        "\n",
        "            #12 is the number of pitch classes\n",
        "            if chromagram.shape != (12,):\n",
        "                chromagram = np.zeros(12)\n",
        "\n",
        "            features=np.array([])\n",
        "            features=np.hstack((chromagram, melspectrogram))\n",
        "\n",
        "            final_features.append(features)\n",
        "            target_emotions.append(emotion)\n",
        "\n",
        "            count += 1\n",
        "            if count % 100 == 0:\n",
        "                print(\"Processed Audio File Number: \", count)\n",
        "\n",
        "    #We return the features and the binary target values.\n",
        "    return np.array(final_features), np.array(binary_label)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "aER6S-_k2a9H",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "ba138f2f-aa65-4899-ac80-e1988afc9b90"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Processed Audio File Number:  100\n",
            "Processed Audio File Number:  200\n",
            "Processed Audio File Number:  300\n",
            "Processed Audio File Number:  400\n",
            "Processed Audio File Number:  500\n",
            "Processed Audio File Number:  600\n",
            "Processed Audio File Number:  700\n",
            "[[7.48462737e-01 7.18022048e-01 7.21704602e-01 ... 6.37150199e-09\n",
            "  6.40108189e-09 6.43972076e-09]\n",
            " [8.22548091e-01 7.54595578e-01 7.46448874e-01 ... 6.67692523e-09\n",
            "  6.55761001e-09 6.61748434e-09]\n",
            " [8.10944796e-01 7.80344844e-01 7.86551654e-01 ... 7.30120675e-09\n",
            "  6.74230138e-09 6.73655975e-09]\n",
            " ...\n",
            " [5.71195185e-01 6.16850078e-01 5.82453609e-01 ... 5.13457007e-06\n",
            "  4.39357450e-07 9.62983115e-09]\n",
            " [7.09048152e-01 6.99507415e-01 6.63865864e-01 ... 8.45409795e-06\n",
            "  7.00323199e-07 9.94233584e-09]\n",
            " [5.45882761e-01 5.39335787e-01 5.64426899e-01 ... 4.41360362e-06\n",
            "  4.30460545e-07 9.14400555e-09]] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0\n",
            " 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0\n",
            " 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
            " 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1\n",
            " 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1\n",
            " 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
            " 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0\n",
            " 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0\n",
            " 0 0 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
            " 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1\n",
            " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1\n",
            " 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1\n",
            " 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n",
            " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0\n",
            " 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n",
            " 0 0 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
            " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1\n",
            " 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 1 1 1 1 1 1\n",
            " 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
            " 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0\n",
            " 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\n"
          ]
        }
      ],
      "source": [
        "#Please change the path below to the path of the folder saved on your computer.\n",
        "data_path = '/content/drive/MyDrive/Audio Files/Audio_Speech_Actors_01-24'\n",
        "X, binary_label = load_extract_features(data_path)\n",
        "\n",
        "print(X, binary_label)"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "X_train, X_test, Y_train, Y_test = train_test_split(X,\n",
        "  binary_label , random_state=104,test_size=0.30, shuffle=True)\n",
        "\n",
        "print(\"Training and testing set, X is the T1, Y is the T2\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "rIU9q8RKpbKg",
        "outputId": "e3b8ded1-3d76-40c5-f538-db93023d7105"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Training and testing set, X is the T1, Y is the T2\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# Gets the K nearest neighbors based on the distances between the point and the\n",
        "# other vector\n",
        "def KNN(vector, point, k):\n",
        "  distances = np.sum((vector - point) ** 2, axis=1)\n",
        "  distances = np.sqrt(distances)\n",
        "  place = np.argsort(distances)\n",
        "  place = place[:k]\n",
        "  return vector[place], place\n",
        "\n",
        "# Classifies a vector based on the given training features and labels from T1\n",
        "\n",
        "def classify(vector, category, point, k):\n",
        "  neighbors, b = KNN(vector, point, k)\n",
        "  classi = np.bincount(category[b])\n",
        "  classi = classi.argmax()\n",
        "  return classi\n",
        "\n",
        "# Performs the cross validation\n",
        "def crossValidation(vector, category, k, splits):\n",
        "  vector_splits = np.array_split(vector, splits)\n",
        "  catagory_splits = np.array_split(category, splits)\n",
        "  scores = []\n",
        "\n",
        "  for i in range(splits):\n",
        "    # Uses one section as the test, the other as the train\n",
        "    New_X_test = vector_splits[i]\n",
        "    New_Y_test = catagory_splits[i]\n",
        "    New_X_train = np.concatenate(vector_splits[:i] + vector_splits[i+1:])\n",
        "    New_Y_train = np.concatenate(catagory_splits[:i] + catagory_splits[i+1:])\n",
        "\n",
        "    classifications = []\n",
        "    # adds all the classifications to a list, and pics the best score\n",
        "    for point in New_X_test:\n",
        "      classification = classify(New_X_train, New_Y_train, point, k)\n",
        "      classifications.append(classification)\n",
        "\n",
        "    score = np.mean(classifications == New_Y_test)\n",
        "    scores.append(score)\n",
        "  return np.mean(scores)\n",
        "\n",
        "score=[]\n",
        "# Tries out the K values, NumberofK is the max range of ks to check\n",
        "# You can also change the value after i to try more number of splits\n",
        "NumberOfK = 140\n",
        "for i in range(1,NumberOfK):\n",
        "  score.append([crossValidation(X_train, Y_train, i, 3), i])\n",
        "\n",
        "# Gets the best score, and it's accuracy in the classification\n",
        "percentageOfMax, positionOfMax  = np.zeros(1), np.zeros(1)\n",
        "for i in score:\n",
        "  if (i[0] > percentageOfMax):\n",
        "    percentageOfMax = i[0]\n",
        "    positionOfMax = i\n",
        "\n",
        "print(\"The highest accuracy  is\", percentageOfMax, \"which occurs at the k value\", positionOfMax)\n",
        "\n",
        "# Gets the accuracy of the classification for the k value we got in the cross validation\n",
        "score = 0\n",
        "classifications = []\n",
        "for point in X_test:\n",
        "  classification = classify(X_train, Y_train, point, positionOfMax[1])\n",
        "  classifications.append(classification)\n",
        "score = np.mean(classifications == Y_test)\n",
        "print(\"When applied to the testing set, the accuracy with k =\",positionOfMax[1], \"is \", score)\n",
        "print(\"Change Number of K to test different sets of ranges of K, \\n At 140, the runtime is 14 seconds But much better accuracy\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "bzSpb4GzPArv",
        "outputId": "46a9baad-2c3a-46f0-c01d-dcd7a92790b0"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The highest accuracy  is 0.7206703910614524 which occurs at the k value [0.7206703910614524, 45]\n",
            "When applied to the testing set, the accuracy with k = 45 is  0.670995670995671\n",
            "Change Number of K to test different sets of ranges of K, \n",
            " At 140, the runtime is 14 seconds But much better accuracy\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# computes the principle components, using the perEntry as the number of values you want.\n",
        "# You will get a perEntry by orginal number of values array\n",
        "def PrincipleComponents(vector, PerEntry):\n",
        "  mean = np.mean(vector, axis=0)\n",
        "  vector = vector - mean\n",
        "  cov = np.cov(np.transpose(vector))\n",
        "  eigenValues, eigenVectors = np.linalg.eig(cov)\n",
        "\n",
        "  sorted = np.argsort(eigenValues)\n",
        "  sorted = np.flip(sorted)\n",
        "  eigenValues = eigenValues[sorted]\n",
        "  eigenVectors = eigenVectors[:, sorted]\n",
        "\n",
        "  W = np.zeros((eigenVectors.shape[0], PerEntry))\n",
        "  for i in range(PerEntry):\n",
        "    W[:, i] = eigenVectors[:, i]\n",
        "  PCA_version = vector.dot(W)\n",
        "  return PCA_version\n",
        "\n",
        "# makes it 1D\n",
        "X_train_pca = PrincipleComponents(X_train, 1)\n",
        "\n",
        "score=[]\n",
        "NumberOfk = 140\n",
        "for i in range(1,NumberOfk):\n",
        "  score.append([crossValidation(X_train_pca, Y_train, i, 3), i])\n",
        "\n",
        "percentageOfMax ,positionOfMax = np.zeros(1), np.zeros(1)\n",
        "\n",
        "# Gets the best K value, and the accuracy\n",
        "for i in score:\n",
        "  if i[0] > percentageOfMax:\n",
        "    percentageOfMax = i[0]\n",
        "    positionOfMax = i\n",
        "\n",
        "print(\"The highest accuracy  is\", percentageOfMax, \"which occurs at the k value\", positionOfMax)\n",
        "\n",
        "# outputs the accuracy of the classifier\n",
        "X_test_pca = PrincipleComponents(X_test, 1)\n",
        "score = 0\n",
        "classifications = []\n",
        "for point in X_test_pca:\n",
        "  classification = classify(X_train_pca, Y_train, point, positionOfMax[1])\n",
        "  classifications.append(classification)\n",
        "score = np.mean(classifications == Y_test)\n",
        "print(\"When applied to the testing set, the accuracy with k =\",positionOfMax[1], \"is \", score)\n",
        "print(\"The runnning time with a range of 140's is shorter, by around 6 seconds total\\n The accuracy takes a hit however\")\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "GqGU045PQTJv",
        "outputId": "1a53d7fc-26ce-40fa-e6b9-1c8654b0c3fb"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The highest accuracy  is 0.7150837988826816 which occurs at the k value [0.7150837988826816, 82]\n",
            "When applied to the testing set, the accuracy with k = 82 is  0.38961038961038963\n",
            "The runnning time with a range of 140's is shorter, by around 6 seconds total\n",
            " The accuracy takes a hit however\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.9.12"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}